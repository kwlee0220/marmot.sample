
def HOME = System.env.HOME
def LAND_PRICES_2018 = "토지/개별공시지가_2018";
def OUTPUT = "$HOME/";


createDataSet(TEMP_CADASTRAL) {
	geometry GC_INFO
	force = true
	from plan('연속지적도에 격자정보 부여') {
		load(LAND_PRICES_2018)
		
		// 각 지적위치에 해당하는 1km 격자 정보를 첨부한다.
		assignGridCell('the_geom', SquareGrid(DataSet(LAND_PRICES_2018), cellSize))
		
		// 격자와 지적 공간 정보 겹치는 영역을 계산하여, 지적에 격자가 차지하는 비율을 계산한다.
		intersection("the_geom", "cell_geom", output:"overlap")
		defineColumn "ratio:double", "(ST_Area(overlap) /  ST_Area(the_geom))"
		
		project('cell_geom as the_geom,pnu,ratio,cell_pos,cell_id')
	}
}


createDataSet(TEMP_GAS_2018) {
	force = true
	from plan('2018년 월별 가스 사용량 합계') {
		// 2018년도 가스 사용량 데이터를 적재한다.
		load(GAS)
		
		// 사용년월에서 '년' 정보를 따로 뽑고, 2018년도 데이터만 선택한다.
		defineColumn("year:short", "사용년월.substring(0, 4)")
		filter("year == 2018")
		
		// '사용연월'에서 '월' 정보를 뽑는다.
		defineColumn("month:short", "사용년월.substring(4, 6)")
		
		// (pnu, month)단위로 그룹핑을하고, 각 그룹에 속한 레코드들의 사용량 값의 합계를 구한다.
		aggregateByGroup("pnu,month", workerCount: 1) { usage = sum("사용량") }
		
		// 'month' 값을 이용하여 태그 컬럼을 생성한다.
		defineColumn("tag:string", "'month_' + month")
		
		// pnu별로 그룹핑을하고, 개월 태그를 기준으로 사용량('usage') 값을 병렬로 수집한다.
		reduceToSingleRecordByGroup('pnu', outSchema, 'tag', 'usage')
		
		// 가스 사용량 값이 0보다 작은 경우, 강제로 0으로 설정한다.
		update COL_NAMES.collect { "if ($it == null) {$it = 0}" }.join(' ')
	}
}
createDataSet(OUT_GRID_GAS2018) {
	geometry GC_INFO
	force = true
	from plan('2018년도 가스 사용량 격자 분석') {
		// 격자분석을 위해, 2018년도 월별 가스 사용량의 PNU 값을에 해당하는 연속지적도 상의 공간 정보를 첨부한다.
		loadHashJoinFile(TEMP_CADASTRAL, 'pnu', TEMP_GAS_2018, 'pnu', output: outCols,
						type: LEFT_OUTER_JOIN, workerCount: 17)
		
		// 비율에 따라 사용량을 곱한다.
		update COL_NAMES.collect { "$it *= ratio" }.join("; ")
		
		// 각 격자별로 가스 사용량의 총합을 구한다.
		aggregateByGroup("cell_id", tags: "the_geom,cell_pos", workerCount: 7,
						COL_NAMES.collect { SUM(it).as(it) })
		
		expand("x:long,y:long", "x = cell_pos.getX(); y = cell_pos.getY()")
		project("the_geom, x, y, *-{the_geom,x,y}")
	}
}
deleteDataSet TEMP_GAS_2018


createDataSet(TEMP_ELECTRO_2018) {
	force = true
	from plan('2018년 월별 전기 사용량 합계') {
		// 2018년도 전기 사용량 데이터를 적재한다.
		load ELECTRO
		
		// 사용년월에서 '년' 정보를 따로 뽑고, 2018년도 데이터만 선택한다.
		defineColumn "year:short", "사용년월.substring(0, 4)"
		filter "year == 2018"
		
		// '사용연월'에서 '월' 정보를 뽑는다.
		defineColumn "month:short", "사용년월.substring(4, 6)"
		
		// (pnu, month)단위로 그룹핑을하고, 각 그룹에 속한 레코드들의 사용량 값의 합계를 구한다.
		aggregateByGroup("pnu,month", workerCount: 1) { usage = sum("사용량") }
		
		// 'month' 값을 이용하여 태그 컬럼을 생성한다.
		defineColumn("tag:string", "'month_' + month")
		
		// pnu별로 그룹핑을하고, 개월 태그를 기준으로 사용량('usage') 값을 병렬로 수집한다.
		reduceToSingleRecordByGroup('pnu', outSchema, 'tag', 'usage')
		
		// 가스 사용량 값이 0보다 작은 경우, 강제로 0으로 설정한다.
		update COL_NAMES.collect { "if ($it == null) {$it = 0}" }.join(' ')
	}
}
createDataSet(OUT_GRID_ELECTRO2018) {
	geometry GC_INFO
	force = true
	from plan('2018년도 전력 사용량 격자 분석') {
		// 격자분석을 위해, 2018년도 월별 전력 사용량의 PNU 값을에 해당하는 연속지적도 상의 공간 정보를 첨부한다.
		loadHashJoinFile(TEMP_CADASTRAL, 'pnu', TEMP_ELECTRO_2018, 'pnu', output: outCols,
						type: LEFT_OUTER_JOIN, workerCount: 17)
		
		// 비율에 따라 사용량을 곱한다.
		update COL_NAMES.collect { "$it *= ratio" }.join("; ")
		
		// 각 격자별로 전력 사용량의 총합을 구한다.
		aggregateByGroup("cell_id", tags: "the_geom,cell_pos", workerCount: 7,
						COL_NAMES.collect { SUM(it).as(it) })
		
		expand("x:long,y:long", "x = cell_pos.getX(); y = cell_pos.getY()")
		project("the_geom, x, y, *-{the_geom,x,y}")
	}
}
deleteDataSet TEMP_ELECTRO_2018


def LAND_COL_NAMES = (2012..2017).collect { "year_$it" }
def LAND_OUT_SCHEMA = LAND_COL_NAMES.inject(RecordSchema.builder()) {
					b, n -> b.addColumn(n, DataType.LONG)
				}.build()
		
createDataSet(TEMP_LAND) {
	force = true
	from plan('2012-2018년 연도별 개별공시지가 집계') {
		// 2012~2017년도 개별공시지가 데이터를 적재한다.
		load LAND_PRICES
		
		project("pnu, 기준년도 as year, 개별공시지가 as usage")
		expand("tag:string", "tag = 'year_' + year")
		
		// pnu별로 그룹핑을하고, 연도태그를 기준으로 공시지가('usage') 값을 병렬로 수집한다.
		reduceToSingleRecordByGroup('pnu', LAND_OUT_SCHEMA, 'tag', 'usage')
		
		// 공시지가 값이 0보다 작은 경우, 강제로 0으로 설정한다.
		update LAND_COL_NAMES.collect { "if ($it == null) {$it = 0}" }.join(' ')
	}
}


def LAND_OUT_COLS = "left.{the_geom, pnu},right.{" + LAND_COL_NAMES.join(",") +
					"},left.{개별공시지가 as year_2018}"
def FULL_LAND_COL_NAMES = (2012..2018).collect { "year_$it" }
createDataSet(OUT_GRID_LAND) {
	geometry GC_INFO
	force = true
	from plan('2012~2018년도 년도별 개별공시지가 격자 분석') {
		// 격자분석을 위해, 2018년도 월별 전력 사용량의 PNU 값을에 해당하는 연속지적도 상의 공간 정보를 첨부한다.
		loadHashJoinFile(LAND_PRICES_2018, 'pnu', TEMP_LAND, 'pnu', output: LAND_OUT_COLS,
						type: LEFT_OUTER_JOIN, workerCount: 25)
		
		// 가스 사용량 값이 0보다 작은 경우, 강제로 0으로 설정한다.
		update FULL_LAND_COL_NAMES.collect { "if ($it == null) {$it = 0}" }.join(' ')
		
		// 공시지가는 평망미터당 지가이므로, 평당액수에 면적을 곱한다.
		defineColumn("area:double", "ST_Area(the_geom)")
		update(FULL_LAND_COL_NAMES.collect { "$it * area" }.join('; '))
		project("*-{area}")
		
		// 각 지적위치에 해당하는 1km 격자 정보를 첨부한다.
		assignGridCell('the_geom', SquareGrid(DataSet(LAND_PRICES_2018), cellSize))
		
		// 격자와 지적 공간 정보 겹치는 영역을 계산하여, 지적에 격자가 차지하는 비율을 계산하고,
		// 이에 따라 공시가격을 보정한다.
		intersection("the_geom", "cell_geom", output:"overlap")
		defineColumn "ratio:double", "(ST_Area(overlap) /  ST_Area(the_geom))"
		update FULL_LAND_COL_NAMES.collect { "$it *= ratio" }.join("; ")
		
		// 각 격자별로 전력 사용량의 총합을 구한다.
		aggregateByGroup("cell_id", tags: "the_geom,cell_pos", workerCount: 7,
						FULL_LAND_COL_NAMES.collect { SUM(it).as(it) })
		
		expand("x:long,y:long", "x = cell_pos.getX(); y = cell_pos.getY()")
		project("the_geom, x, y, *-{the_geom,x,y}")
	}
}
deleteDataSet TEMP_LAND

deleteDataSet TEMP_CADASTRAL
